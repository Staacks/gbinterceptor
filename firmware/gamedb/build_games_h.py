###
# This Python script generates the content of games.h.
# Do not edit games.h directly, but change games.csv and run this script to
# update games.h (on Linux systems just redirect the output to games.h)
# The reason for not editing games.h directly is that the data has to be
# sorted by vramHash2, the precompiler define for the list length has to be
# set correctly and the entries of gameInfosDirectory have to point at the
# right indices.
###

import csv
import re
import sys

gameInfos = []
gameInfosDirectory = []
maxBranchBasedFixCount = 0
maxRegisterDuringDMACount = 0

with open('games.csv') as csvfile:
    reader = csv.DictReader(csvfile, delimiter=',', quotechar='"', skipinitialspace=True)
    currentDirectoryIndex = -1
    for row in sorted(reader, key=lambda d: d["vramHash2"]):
        hashIndex = (int(row["vramHash2"], 16) >> 24) & 0xff
        while hashIndex > currentDirectoryIndex:
            gameInfosDirectory.append(len(gameInfos))
            currentDirectoryIndex += 1
        gameInfo = {}
        gameInfo["vramHash1"] = row["vramHash1"]
        gameInfo["vramHash2"] = row["vramHash2"]
        gameInfo["title"] = row["title"]
        gameInfo["branchBasedFixes"] = []
        if row["fixes"] != "":
            for fix in row["fixes"].split("|"):
                parts = re.search("\s*([a-zA-Z]+)\((.+)\)\s*", fix)
                if parts == None:
                    print("Parse error: " + fix, file=sys.stderr)
                if parts[1].lower() == "dmaFix".lower():
                    gameInfo["dmaFix"] = parts[2]
                elif parts[1].lower() == "useImmediateIRQ".lower():
                    gameInfo["useImmediateIRQ"] = parts[2]
                elif parts[1].lower() == "disableStatSyncs".lower():
                    gameInfo["disableStatSyncs"] = parts[2]
                elif parts[1].lower() == "disableLySyncs".lower():
                    gameInfo["disableLySyncs"] = parts[2]
                elif parts[1].lower() == "branchBasedFix".lower():
                    branchBasedFixParameters = parts[2].split(",")
                    branchBasedFix = {}
                    branchBasedFix["jumpAddress"] = branchBasedFixParameters[0].strip()
                    branchBasedFix["fixTarget"] = branchBasedFixParameters[1].strip()
                    branchBasedFix["takenMethod"] = branchBasedFixParameters[2].strip()
                    branchBasedFix["takenValue"] = branchBasedFixParameters[3].strip()
                    branchBasedFix["notTakenMethod"] = branchBasedFixParameters[4].strip()
                    branchBasedFix["notTakenValue"] = branchBasedFixParameters[5].strip()
                    gameInfo["branchBasedFixes"].append(branchBasedFix)
                    if len(gameInfo["branchBasedFixes"]) > maxBranchBasedFixCount:
                        maxBranchBasedFixCount = len(gameInfo["branchBasedFixes"])
                elif parts[1].lower() == "writeRegistersDuringDMA".lower():
                    registerDuringDMAParameters = parts[2].split(",")
                    if len(registerDuringDMAParameters) > maxRegisterDuringDMACount:
                        maxRegisterDuringDMACount = len(registerDuringDMAParameters)
                    gameInfo["writeRegistersDuringDMA"] = parts[2]
                else:
                    print("Unknown fix: " + fix, file=sys.stderr)
        gameInfo["comment"] = row["comment"]
        gameInfos.append(gameInfo)

while 256 > currentDirectoryIndex:
    gameInfosDirectory.append(len(gameInfos))
    currentDirectoryIndex += 1

print("// Do not edit this file directly!")
print("// Edit games.csv instead and use the Python script build_games_h.py to regenerate games.c.");
print("")
print("#ifndef GBINTERCEPTOR_GAMES")
print("#define GBINTERCEPTOR_GAMES")
print("#define GAME_LIST_SIZE " + str(len(gameInfos)))
print("")
print("GameInfo __in_flash(\"games\") gameInfos[GAME_LIST_SIZE] = {")
for gameInfo in gameInfos:
    print("    {", end="")
    print(".vramHash1 = " + gameInfo["vramHash1"] + ", ", end="")
    print(".vramHash2 = " + gameInfo["vramHash2"] + ", ", end="")
    print(".dmaFix = " + gameInfo.get("dmaFix", "0x0000") + ", ", end="")
    print(".useImmediateIRQ = " + gameInfo.get("useImmediateIRQ", "false") + ", ", end="")
    print(".disableStatSyncs = " + gameInfo.get("disableStatSyncs", "false") + ", ", end="")
    print(".disableLySyncs = " + gameInfo.get("disableLySyncs", "false") + ", ", end="")
    print(".branchBasedFixes = {", end="")
    for branchBasedFix in gameInfo["branchBasedFixes"]:
        print("{", end="")
        print(".jumpAddress = " + branchBasedFix["jumpAddress"] + ", ", end="")
        print(".fixTarget = " + branchBasedFix["fixTarget"] + ", ", end="")
        print(".takenMethod = " + branchBasedFix["takenMethod"] + ", ", end="")
        print(".takenValue = " + branchBasedFix["takenValue"] + ", ", end="")
        print(".notTakenMethod = " + branchBasedFix["notTakenMethod"] + ", ", end="")
        print(".notTakenValue = " + branchBasedFix["notTakenValue"], end="")
        print("}, ", end="")
    print("}, ", end="")
    print(".writeRegistersDuringDMA = {" + gameInfo.get("writeRegistersDuringDMA", "") + "}, ", end="")
    print(".title = \"" + gameInfo["title"] + "\", " + " "*(18-len(gameInfo["title"])), end="")
    print("}, // " + gameInfo["comment"])

print("};")
print("")
print("uint16_t gameInfoDirectory[257] = {")
print("    " + ", ".join(map(str, gameInfosDirectory)))
print("};")
print("#endif")
print("All done. Make sure that BRANCH_BASED_FIX_LIST_SIZE is at least " + str(maxBranchBasedFixCount) + " and DMA_REGISTER_MAP_SIZE is at least " + str(maxRegisterDuringDMACount) + " in game_detection.h.", file=sys.stderr)

